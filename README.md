# MidPass

Скрипт для автоматического подтверждения заявки в листе ожидания записи в российское консульство на получение загранпаспорта для граждан РФ за границей.

## Оглавление

1. [Установка](#установка)
   1. [Использование в странах, отличных от Грузии](#использование-в-странах-отличных-от-грузии)
2. [Использование](#использование)
   1. [А меня не заблокируют?](#а-меня-не-заблокируют) 
   2. [Скриншот](#скриншот)
   3. [Видео](#видео)
3. [Предыстория](#предыстория)
4. [Как ломалась CAPTCHA](#как-ломалась-captcha)
5. [Реализация](#реализация)
   1. [Почему каптча решается только 1 раз?](#почему-каптча-решается-только-1-раз)

## Установка

Установка максимально простая, не требуется ничего дополнительно скачивать и устанавливать. Дистрибутив уже содержит в себе интерпретатор PHP и все необходимые библиотеки.

1. Скачать архив `midpass-1.0.2.z` из раздела "Releases".
2. Распаковать в любую папку.
3. Открыть файл `config.txt` и вставить в соответствующие поля свой email и пароль, под которым вы зарегистрированы на сайте q.midpass.ru

### Использование в странах, отличных от Грузии

Данный скрипт был написан для использования в Грузии, и файл `config.txt` по умолчанию содержит параметры TIMEZONE, COUNTRY_ID и SERVICE_PROVIDER_ID заполненные для Грузии. Для использования скрипта в других странах, нужно подставить вашу таймзону, ID страны и ID учреждения. Список поддерживаемых таймзон [здесь](https://www.php.net/manual/en/timezones.php). Таймзона нужна для корректного определения момента, когда начинается новый 24-часовой интервал подтверждения. COUNTRY_ID и SERVICE_PROVIDER_ID можно найти на странице авторизации: в Chrome правой кнопкой на выпадающем списке стран, тыкаем в "Inspect" и в консоли разработчика разворачиваем подсвеченный элемент `<select>`. Выбрав страну, аналогичным образом смотрим ID учреждения и подставляем всё в файл `config.txt`.

## Использование

Просто каждый день запускать файл `confirm-queue.cmd`. Откроется чёрное окно консоли, в котором будет отображаться ход процесса подтверждения, обычно занимает около 10 секунд. По окончанию окно будет ожидать нажатия любой клавиши для завершения. Вся выводимая в окне информация автоматически сохраняется в файле `logs/confirm-queue.log` с датой и временем в начале каждой строки. Так можно будет следить за ходом выполнения, скоростью движения в очереди.

При запуске скрипт запрашивает каптчу, решает её, отправляет форму авторизации, получает в ответ сессионную куку, с этой кукой запрашивает от API список заявок в листе ожидания, смотрит в каждой заявке на поле `canConfirm` и если оно `TRUE`, то отправляет запрос на подтверждение заявки, проверяет результат, разлогинивается. Скрипт не будет пытаться подтверждать одну и ту же заявку дважды в течение одного дня.

Кроме того, поскольку предполагается, что скрипт будет запускаться не вручную, а через Планировщик заданий Windows или какой-то аналог cron, например, раз в час, в скрипте предусмотрено сохранение данных о времени последних успешных подтверждений заявок в файле `temp/confirm-queue.json`. Таким образом, если в рамках текущего 24-часового интервала все заявки уже подтверждены, скрипт не будет впустую логиниться на сайт и проверять список заявок. Это сделано, чтобы снизить число обращений к серверу и не привлекать лишний раз внимание частыми регулярными обращениями. Чтобы при запуске скрипта через Планировщик заданий не появлялось каждый раз чёрное окно консоли, вместо php.exe нужно использовать php-win.exe. Тогда работа скрипта будет полностью незаметной, а о его работе можно будет узнать из лог-файла.

### А меня не заблокируют?

Сайт q.midpass.ru уже содержит в себе защиту от роботов, которая выявляет подозрительные запросы, блокирует вход на 1 час и высылает новый пароль на email. Правда, под действие этой защиты в основном попадают обычные люди, которые честно подтверждают всё вручную. Открытый в браузере сайт фоном отправляет запросы на сервер. Предположительно эти запросы и вызывают блокировку. Также рекомендуется явным образом разлогиниваться перед закрытием вкладки. А скрипт наоборот выполняет минимальное кол-во запросов к серверу и не триггерит блокировщик: зашёл, подтвердил, вышёл. Возможно, эта защита от роботов рассчитана в основном на какое-то централизованное подтверждение множества аккаунтов с одного IP адреса. За 3 недели испытаний скрипта у меня не было ни одной блокировки.

Также для цели маскировки, скрипт притворяется браузером Google Chrome версии 121 под Windows 10, отправляет все те же самые заголовки и куки, которые отправляет настоящий браузер. Поэтому единственный способ выявить работу скрипта на стороне сервера — это малые задержки между запросами (их можно добавить) и отсутствие скачивания сопутствующих HTML, CSS, JS файлов и картинок. Но этот способ выявления довольно ненадёжный, т.к. существуют кэширующие прокси и могут быть различные браузерные расширения, усиливающие кэширование.

### Скриншот

![Preview](preview.png)

### Видео

Демонстрационное видео работы скрипта: https://disk.yandex.ru/i/IiZOWZjfQwu4UQ

## Предыстория

С 2022 года я живу в Грузии. Переезд был спешным, обновить загранпаспорт не успел, переехал с истекающим через полгода загранпаспортом. Из-за наплыва эмигрантов в Грузии (и во многих других странах), чтобы попасть на подачу документов на загранпаспорт, нужно сперва отстоять электронную очередь (лист ожидания) на сайте q.midpass.ru. Начинать приходится примерно с 3200-3600 места в очереди. Причём, нужно не просто один раз встать в эту очередь, но и каждый день подтверждать актуальность своей заявки. При регулярном подтверждении заявки происходит движение к началу очереди. Те, кто подтверждают чаще, двигаются по очереди быстрее, но нельзя подтверждать чаще, чем 1 раз в сутки. Таким образом создаётся конкурентная среда, в которой те люди, которым нужно сильнее (которые чаще подтверждают), получат запись раньше тех, кому нужно не очень сильно (кто забывает подтверждать). При завершении очереди сайт предоставляет случайный слот в виде даты и времени, который нужно подтвердить в течение 24 часов или отказаться, попав обратно в очередь примерно на 400-е место.

В 2022 я ставил себе напоминания и будильники, честно подтверждал заявку каждый день в течение 3 месяцев, и в итоге благополучно получил свой паспорт. Но в 2024 я решил, что было бы неплохо получить второй загранпаспорт на случай, если один вдруг потеряется (или отберут). Благо предыдущий загранпаспорт уже закончился, и закон позволяет иметь 2 загранпаспорта. Я снова встал в лист ожидания и начал подтверждать по будильнику каждый день. Возможность подтверждения разблокируется каждую ночь в 3:00 по МСК.

В феврале 2022 из-за трудностей на работе у меня внезапно стало много свободного времени. Чтобы провести его с пользой, я решил попробовать автоматизировать этот утомительный процесс ежедневного подтверждения. Я давно обратил внимание на то, что CAPTCHA на этом сайте очень простая: буквенно-цифровой код появляется на картинке в одном и том же месте, одним и тем же шрифтом, одного и того же цвета. Первый символ всегда буква, затем всегда 5 цифр. Эта каптча буквально просится, чтобы её взломали! Сложность создают лишь цветные круги, случайно наложенные поверх символов, которые создают шум.

Примеры каптч:

![CAPTCHA example](php/tests/captcha-062.jpg)
![CAPTCHA example](php/tests/captcha-071.jpg)
![CAPTCHA example](php/tests/captcha-315.jpg)
![CAPTCHA example](php/tests/captcha-451.jpg)
![CAPTCHA example](php/tests/captcha-695.jpg)
![CAPTCHA example](php/tests/captcha-951.jpg)

## Как ломалась CAPTCHA

Это были одни из самых эмоционально насыщенных для меня дней, а точнее 2 дня, в которые я активно занимался R&D. Я мало ел, не гулял, не играл, а запоем пробовал самые безумные гипотезы, борясь за точность и крича от радости при повышении точности на каждые 0.1%.

Я начал с небольшой тестовой выборки в 10 каптч, на которых реализовал базовый алгоритм. Алгоритм перебирает алфавит, создаёт картинку каждой буквы и затем попиксельно сравнивает её с соответствующим местом в картинке с каптчей, находя суммарную разницу между пикселями. Разницу между пикселями я представил как разницу двух векторов в трехмерном пространстве RGB (кортеж из 3 чисел от 0 до 255). Разница находилась по теореме Пифагора. Потом я увеличил тестовую выборку до 100 каптч и сделал автоматический тест всей выборки, чтобы быстро понимать какие изменения ведут к улучшению, а какие к ухудшению. Все 100 каптч пришлось решить вручную. Точность решения оказалась в районе 88% — это был результат первого дня.

Второй день я посвятил повышению точности алгоритма. Я увеличил тестовую выборку до 999 каптч. Из них 100 каптч я смог решить вручную, но понял, что решить оставшиеся 799 каптч для меня слишком тяжело и нужна какая-то автоматизация на этом этапе. Поскольку у меня уже был алгоритм, который в 88% правильно решал каптчу, я использовал его, чтобы решить оставшиеся 799 каптч. Сначала я вручную проверял правильность каптч. Проверять и исправлять нечастые ошибки было гораздо быстрее, чем решать полностью самому. Но и это было недостаточно быстро, плюс оставалась вероятность пропустить ошибку. Тогда я сформировал большую картинку со всеми каптчами в виде сетки, поверх которых я нарисовал распознанные символы белым шрифтом. При правильном распознании каптчи её символы практически стирались, вместо них была лишь небольшая остаточная теневая обводка (вызванная скорее всего размытием от JPEG). И на большой картинке визуально сразу подсвечивались неправильно распознанные символы. Плюс на большой картинке гораздо легче смотреть сразу много каптч, чем листать картинку за картинкой. Так я получил 999 распознанных каптч.

Чтобы дальше повышать точность, нужно было решить проблему со шрифтом. Я перепробовал все основные шрифты. Ближе всего подходил шрифт Tahoma, но всё же некоторые символы накладывались не идеально. Например, у 4-ки горизонтальная линия была чуть ниже, чем надо. Были проблемы с буквами "m", "n", "r", "h". Тогда я решил, что вместо шрифта можно использовать заготовленные картинки с символами, взятыми из самих картинок с каптчами. Нужно было только выбрать максимально чистые символы, не зашумлённые цветными кругами. Поскольку, при переборе символов, я вычислял суммарную разницу пикселей каждого символа, мне не составило труда среди 999 каптч найти идеальные картинки всех букв и цифр. Всех, кроме буквы "z" — этот символ нигде не встречается. Похоже, что разработчики неправильно поставили условие для диапазона и один символ пропустили. Картинки символов лежат в `assets/captcha/chars`. Переход на картинки букв повысил точность до 93%.

Далее я пытался снизить чувствительность алгоритма к шуму (к цветным кругам), занизив разницу для цветных пикселей. Также чтобы повысить точность различения похожих букв таких как "n" и "h", "r" и "n" я усилил разницу, если в исходной картинке буквы есть серый пиксель (цвет символа), а в картинке каптчи там белый пиксель, или наоборот. Таким образом удалось повысить точность определения визуально похожих символов, отличающихся лишь небольшим хвостиком, который не даёт значительной разницы в условиях шума. Например, между символами "h" и "n", "n" и "r", "y" и "v". Ещё была проблема с буквами разной ширины, из-за которой узкая буква "r" в ряде случаев именно из-за своего малого размера давала меньшую среднепиксельную разницу в условиях шума, чем "n" и "m". Пришлось повысить ценность широких букв над узкими при той же среднепиксельной разнице. Это решило проблему. Пробовал ещё делать предварительную очистку картинки каптчи от JPEG-шума, заменяя пиксели близкие к белому на белый. Но эта идея принесла лишь ухудшение точности.

По итогу всех экспериментов с ручным подбором функций и подгонкой числовых значений констант удалось добиться точности 98.2% на выборке из 999 каптч. На этом я решил остановиться. Точность и так уже достаточно высокая. Тем более, что для моей цели и не нужна высокая точность, ведь ошибку каптчи можно обрабатывать и просто повторять попытку с новой каптчей после небольшой паузы. Плюс можно получать обратную связь от решателя каптчи в виде точности определения конкретной каптчи, и если точность низкая, то просто запрашивать новую картинку, не отправляя форму авторизацией с недостоверной каптчей.

Класс решателя каптчи (`\App\CaptchaSolver\CaptchaSolverQMidPass`) нарочно выглядит несколько грязновато. В нём много закомментированных участков кода, присутствуют элементы плохих практик в лице публичных свойств (вместо геттеров), неинформативных названий методов `colorDiff1()` и `colorDiff2()`. Потому что на этапе экспериментов важнее как можно быстрее проверить гипотезу, получить результат, а не вылизывать заранее код, который возможно вообще не пригодится. Тем самым я хотел запечатлеть условно "творческий беспорядок" и момент, на котором было найдено финальное решение, до его приведения в порядок. 

## Реализация

Скрипт написан на языке PHP 8.0. Для простоты и легковесности, скрипт не использует никакие фреймворки. Скрипт лишь использует несколько Composer пакетов:

* `guzzlehttp/guzzle` — HTTP-клиент, ОО-обёртка вокруг cURL;
* `symfony/console` — вспомогательный компонент для консольных команд (с его помощью в консоли выводится цветной текст и текстовая таблица с данными по заявкам в листе ожидания);
* `monolog/monolog` — логгер, используется для вывода сообщений как в консоль, так и в лог-файл;
* `nesbot/carbon` — расширение класса `DateTime`, предоставляющее чуть больше возможностей и удобства;
* `vlucas/phpdotenv` — считывает переменные окружения из файла `config.txt` и добавляет в текущее окружение;
* `luracast/config` — предоставляет доступ к конфигам, которые в свою очередь используют переменные окружения;
* `gugglegum/retry-helper` — это мой пакет, позволяющий элегантно повторять попытки выполнения действия при ошибках (с логгером, с увеличивающимися случайными задержками между попытками, с коллбэками, позволяющими гибко управлять поведением), используется для повторов в случае какой-либо ошибки сетевого уровня, ошибок на стороне сервера или при неправильном решении каптчи, но мгновенно завершает работу при фатальных ошибках типа неверного пароля или 400-ых ошибок HTTP.

Точкой входа для всех консольных скриптов является файл `console.php`, который получает на вход первым аргументом командной строки имя команды, и используя простейший роутер команд, вызывает объект соответствующей команды и передаёт в него простейший DI-контейнер в лице `\App\ResourceManager`. Роутер команд просто преобразует имя команды вида "do-some-stuff" в имя класса "DoSomeStuffCommand", этого по идее достаточно, но дополнительно в роутере явно перечисляются классы команд. Таким образом задаётся описание для команды "help", плюс статический анализ PhpStorm перестаёт ругаться на то, что классы команд нигде не используются.

Команда для подтверждения заявки называется "confirm-queue", её реализация находится в классе `\App\Console\Commands\ConfirmQueueCommand`. Скрипт использует `\GuzzleHttp\Client` для HTTP-запросов и `\GuzzleHttp\Cookie\CookieJar` для хранения кук. Скрипт корректно обрабатывает возникающие ошибки, и если эти ошибки не перманентные, то выжидает несколько секунд (случайное кол-во) и повторяет попытки (обычно до 5 раз). Не перманентные ошибки — это ошибки сервера (HTTP 5xx), ошибки соединения и ошибка проверки CAPTCHA. А вот ошибки клиента (HTTP 4xx) и неправильный пароль — это перманентные ошибки. После них скрипт уже не повторяет попытки.

### Почему каптча решается только 1 раз?

При подтверждении через браузер пользователю нужно 2 раза вводить каптчу: один раз при входе, второй раз при подтверждении заявки. Однако, я обнаружил ошибку в работе сайта, о существовании которой я изначально догадывался. Она позволяет вводить каптчу только 1 раз. Дело в том, что код каптчи хранится в сессии и обновляется при запросе новой каптчи. Но если эту каптчу не запрашивать, то её код остаётся прежним и его можно использовать повторно. Проверка каптчи на сайте не очищает её код в сессии. Что ж, нам же лучше!
